// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var ReasonReact = require("reason-react/src/ReasonReact.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Work$Workhours = require("./Work.bs.js");
var DateUtil$Workhours = require("./DateUtil.bs.js");

function str(prim) {
  return prim;
}

function unfinishedWork(workList) {
  return workList.filter((function (w) {
                return w[/* duration */2] === 0;
              }));
}

function latestOnDate(date, workList) {
  return Js_primitive.undefined_to_opt(workList.filter((function (w) {
                        return DateUtil$Workhours.isSameDay(w[/* start */1], date);
                      })).sort((function (w1, w2) {
                      return DateUtil$Workhours.compareAsc(w1[/* start */1], w2[/* start */1]);
                    })).pop());
}

function diffInHours(d1, d2) {
  return (d2.getTime() - d1.getTime()) / 1000 / 60 / 60;
}

function roundToQuarters(v) {
  return Math.round(v * 4) / 4;
}

function dateToDiff(d) {
  return roundToQuarters(diffInHours(d, new Date()));
}

function inProgressWorkToday(l) {
  return latestOnDate(new Date(), unfinishedWork(l));
}

var component = ReasonReact.reducerComponent("Home");

function workInProgressToUpdatedWork(inProgress, hours) {
  var match = hours > 4;
  return /* record */[
          /* id */inProgress[/* id */0],
          /* start */inProgress[/* start */1],
          /* duration */hours,
          /* lunch */match ? 0.5 : 0,
          /* userid */inProgress[/* userid */4]
        ];
}

function stopWork(workList) {
  return /* UpdateWithSideEffects */Block.__(2, [
            /* Stopping */2,
            (function (self) {
                var match = inProgressWorkToday(workList);
                if (match !== undefined) {
                  Work$Workhours.save(match).then((function (work) {
                            return Promise.resolve(Curry._1(self[/* send */3], /* WorkStopped */Block.__(0, [work])));
                          })).catch((function (err) {
                          console.log("Error starting work: ", err);
                          return Promise.resolve(Curry._1(self[/* send */3], /* Failed */Block.__(1, ["Error starting work"])));
                        }));
                  return /* () */0;
                } else {
                  return Curry._1(self[/* send */3], /* Failed */Block.__(1, ["Trying to stop work not in progress"]));
                }
              })
          ]);
}

function startWork_001(self) {
  var newWork_001 = /* start */new Date();
  var newWork = /* record */[
    /* id */undefined,
    newWork_001,
    /* duration */0,
    /* lunch */0,
    /* userid */undefined
  ];
  Work$Workhours.save(newWork).then((function (work) {
            return Promise.resolve(Curry._1(self[/* send */3], /* WorkStarted */Block.__(2, [work])));
          })).catch((function (err) {
          console.log("Error starting work: ", err);
          return Promise.resolve(Curry._1(self[/* send */3], /* Failed */Block.__(1, ["Error starting work"])));
        }));
  return /* () */0;
}

var startWork = /* UpdateWithSideEffects */Block.__(2, [
    /* Starting */1,
    startWork_001
  ]);

function make(workList, handleAction, _) {
  return /* record */[
          /* debugName */component[/* debugName */0],
          /* reactClassInternal */component[/* reactClassInternal */1],
          /* handedOffState */component[/* handedOffState */2],
          /* willReceiveProps */component[/* willReceiveProps */3],
          /* didMount */component[/* didMount */4],
          /* didUpdate */component[/* didUpdate */5],
          /* willUnmount */component[/* willUnmount */6],
          /* willUpdate */component[/* willUpdate */7],
          /* shouldUpdate */component[/* shouldUpdate */8],
          /* render */(function (self) {
              var match = inProgressWorkToday(workList);
              var match$1 = self[/* state */1];
              var tmp;
              if (typeof match$1 === "number") {
                switch (match$1) {
                  case 0 : 
                      tmp = React.createElement("div", undefined);
                      break;
                  case 1 : 
                      tmp = React.createElement("div", undefined, "Starting work...");
                      break;
                  case 2 : 
                      tmp = React.createElement("div", undefined, "Stopping work...");
                      break;
                  
                }
              } else {
                tmp = React.createElement("div", undefined, React.createElement("p", {
                          className: "error"
                        }, "Error: " + match$1[0]), React.createElement("button", {
                          onClick: (function () {
                              return Curry._1(self[/* send */3], /* Reset */2);
                            })
                        }, "Ok"));
              }
              return React.createElement("div", undefined, React.createElement("h1", undefined, "Home page"), match !== undefined ? React.createElement("div", undefined, React.createElement("p", undefined, Pervasives.string_of_float(dateToDiff(match[/* start */1])) + " hours and counting"), React.createElement("button", {
                                    onClick: (function () {
                                        return Curry._1(self[/* send */3], /* StopWork */0);
                                      })
                                  }, "Stop work")) : React.createElement("div", undefined, React.createElement("p", undefined, "You are not working"), React.createElement("button", {
                                    onClick: (function () {
                                        return Curry._1(self[/* send */3], /* StartWork */1);
                                      })
                                  }, "Start work")), tmp);
            }),
          /* initialState */(function () {
              return /* Initial */0;
            }),
          /* retainedProps */component[/* retainedProps */11],
          /* reducer */(function (action, _) {
              if (typeof action === "number") {
                switch (action) {
                  case 0 : 
                      return stopWork(workList);
                  case 1 : 
                      return startWork;
                  case 2 : 
                      return /* Update */Block.__(0, [/* Initial */0]);
                  
                }
              } else {
                switch (action.tag | 0) {
                  case 0 : 
                      Curry._1(handleAction, /* WorkUpdate */Block.__(1, [action[0]]));
                      return /* Update */Block.__(0, [/* Initial */0]);
                  case 1 : 
                      return /* Update */Block.__(0, [/* Error */[action[0]]]);
                  case 2 : 
                      Curry._1(handleAction, /* WorkAdd */Block.__(0, [action[0]]));
                      return /* Update */Block.__(0, [/* Initial */0]);
                  
                }
              }
            }),
          /* jsElementWrapped */component[/* jsElementWrapped */13]
        ];
}

exports.str = str;
exports.unfinishedWork = unfinishedWork;
exports.latestOnDate = latestOnDate;
exports.diffInHours = diffInHours;
exports.roundToQuarters = roundToQuarters;
exports.dateToDiff = dateToDiff;
exports.inProgressWorkToday = inProgressWorkToday;
exports.component = component;
exports.workInProgressToUpdatedWork = workInProgressToUpdatedWork;
exports.stopWork = stopWork;
exports.startWork = startWork;
exports.make = make;
/* component Not a pure module */
